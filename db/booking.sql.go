// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: booking.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bookTicket = `-- name: BookTicket :one
INSERT INTO ticket (user_id, schedule_id, seat_id, totalprice, coupon)
VALUES ($1, $2, $3, $4, $5)
RETURNING ticket.id
`

type BookTicketParams struct {
	UserID     pgtype.Int4
	ScheduleID pgtype.Int4
	SeatID     pgtype.Int4
	Totalprice pgtype.Int4
	Coupon     pgtype.Int4
}

func (q *Queries) BookTicket(ctx context.Context, arg BookTicketParams) (int32, error) {
	row := q.db.QueryRow(ctx, bookTicket,
		arg.UserID,
		arg.ScheduleID,
		arg.SeatID,
		arg.Totalprice,
		arg.Coupon,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getPrice = `-- name: GetPrice :one
SELECT price FROM price WHERE type = $1
`

func (q *Queries) GetPrice(ctx context.Context, type_ pgtype.Text) (pgtype.Int4, error) {
	row := q.db.QueryRow(ctx, getPrice, type_)
	var price pgtype.Int4
	err := row.Scan(&price)
	return price, err
}

const getScheduleCinema = `-- name: GetScheduleCinema :many
SELECT DISTINCT schedule.cinema_id, name 
FROM schedule 
INNER JOIN cinema ON schedule.cinema_id = cinema.cinema_id
WHERE movie_id = $1 AND schedule_movie_date = $2
`

type GetScheduleCinemaParams struct {
	MovieID           pgtype.Int4
	ScheduleMovieDate pgtype.Date
}

type GetScheduleCinemaRow struct {
	CinemaID pgtype.Int4
	Name     pgtype.Text
}

func (q *Queries) GetScheduleCinema(ctx context.Context, arg GetScheduleCinemaParams) ([]GetScheduleCinemaRow, error) {
	rows, err := q.db.Query(ctx, getScheduleCinema, arg.MovieID, arg.ScheduleMovieDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScheduleCinemaRow
	for rows.Next() {
		var i GetScheduleCinemaRow
		if err := rows.Scan(&i.CinemaID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleDate = `-- name: GetScheduleDate :many
SELECT DISTINCT schedule_movie_date FROM schedule
WHERE movie_id = $1
`

func (q *Queries) GetScheduleDate(ctx context.Context, movieID pgtype.Int4) ([]pgtype.Date, error) {
	rows, err := q.db.Query(ctx, getScheduleDate, movieID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Date
	for rows.Next() {
		var schedule_movie_date pgtype.Date
		if err := rows.Scan(&schedule_movie_date); err != nil {
			return nil, err
		}
		items = append(items, schedule_movie_date)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduleTime = `-- name: GetScheduleTime :many
SELECT schedule_id ,schedule_movie_start, schedule.room_id, room.type 
FROM schedule INNER JOIN room ON schedule.room_id = room.room_id
WHERE movie_id = $1 AND schedule_movie_date = $2 AND schedule.cinema_id = $3
`

type GetScheduleTimeParams struct {
	MovieID           pgtype.Int4
	ScheduleMovieDate pgtype.Date
	CinemaID          pgtype.Int4
}

type GetScheduleTimeRow struct {
	ScheduleID         int32
	ScheduleMovieStart pgtype.Time
	RoomID             pgtype.Int4
	Type               pgtype.Text
}

func (q *Queries) GetScheduleTime(ctx context.Context, arg GetScheduleTimeParams) ([]GetScheduleTimeRow, error) {
	rows, err := q.db.Query(ctx, getScheduleTime, arg.MovieID, arg.ScheduleMovieDate, arg.CinemaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScheduleTimeRow
	for rows.Next() {
		var i GetScheduleTimeRow
		if err := rows.Scan(
			&i.ScheduleID,
			&i.ScheduleMovieStart,
			&i.RoomID,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeat = `-- name: GetSeat :many
SELECT seat_id, seat.room_id, rowss, columnss, schedule_id, schedule_movie_date, schedule_movie_start, movie_id, schedule.room_id, cinema_id 
FROM seat INNER JOIN schedule ON seat.room_id = schedule.room_id
WHERE schedule_id = $1
ORDER BY rowss
`

type GetSeatRow struct {
	SeatID             int32
	RoomID             pgtype.Int4
	Rowss              pgtype.Text
	Columnss           pgtype.Int4
	ScheduleID         int32
	ScheduleMovieDate  pgtype.Date
	ScheduleMovieStart pgtype.Time
	MovieID            pgtype.Int4
	RoomID_2           pgtype.Int4
	CinemaID           pgtype.Int4
}

func (q *Queries) GetSeat(ctx context.Context, scheduleID int32) ([]GetSeatRow, error) {
	rows, err := q.db.Query(ctx, getSeat, scheduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeatRow
	for rows.Next() {
		var i GetSeatRow
		if err := rows.Scan(
			&i.SeatID,
			&i.RoomID,
			&i.Rowss,
			&i.Columnss,
			&i.ScheduleID,
			&i.ScheduleMovieDate,
			&i.ScheduleMovieStart,
			&i.MovieID,
			&i.RoomID_2,
			&i.CinemaID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSelectedSeat = `-- name: GetSelectedSeat :many
SELECT seat_id FROM ticket
WHERE schedule_id = $1
`

func (q *Queries) GetSelectedSeat(ctx context.Context, scheduleID pgtype.Int4) ([]pgtype.Int4, error) {
	rows, err := q.db.Query(ctx, getSelectedSeat, scheduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Int4
	for rows.Next() {
		var seat_id pgtype.Int4
		if err := rows.Scan(&seat_id); err != nil {
			return nil, err
		}
		items = append(items, seat_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicket = `-- name: GetTicket :one
SELECT schedule_movie_date, schedule_movie_start, seat.rowss, seat.columnss, movie.title, cinema.name, room.room_id, room.type, ticket.totalprice, movie.url 
FROM ticket 
INNER JOIN schedule ON ticket.schedule_id = schedule.schedule_id
INNER JOIN movie ON schedule.movie_id = movie.movie_id
INNER JOIN cinema ON schedule.cinema_id = cinema.cinema_id
INNER JOIN room ON schedule.room_id = room.room_id
INNER JOIN seat ON ticket.seat_id = seat.seat_id
WHERE ticket.id = $1
`

type GetTicketRow struct {
	ScheduleMovieDate  pgtype.Date
	ScheduleMovieStart pgtype.Time
	Rowss              pgtype.Text
	Columnss           pgtype.Int4
	Title              pgtype.Text
	Name               pgtype.Text
	RoomID             int32
	Type               pgtype.Text
	Totalprice         pgtype.Int4
	Url                pgtype.Text
}

func (q *Queries) GetTicket(ctx context.Context, id int32) (GetTicketRow, error) {
	row := q.db.QueryRow(ctx, getTicket, id)
	var i GetTicketRow
	err := row.Scan(
		&i.ScheduleMovieDate,
		&i.ScheduleMovieStart,
		&i.Rowss,
		&i.Columnss,
		&i.Title,
		&i.Name,
		&i.RoomID,
		&i.Type,
		&i.Totalprice,
		&i.Url,
	)
	return i, err
}
